// МАССИВЫ

// ОБЩИЕ ПОНЯТИЯ
// ФОРМАТ ЗАПИСИ МАССИВОВ
// ОПЕРАТОР СРАВНЕНИЯ ДЛЯ МАССИВОВ И ОБЪЕКТОВ
// МАССИВ ПРОТИВ ОБЪЕКТА
// МЕТОДЫ МАССИВОВ
// МЕТОД forEach
// МЕТОД map

// ОБЩИЕ ПОНЯТИЯ
// Массив - это объект с цифровыми именами свойств, то есть свойства у массива называются 0, 1, 2, 3 и так далее
// Массивы в JS могут сохранять абсолютно разные значения
// Переменная хранит ссылку на массив (так как это объект) в определенном месте в памяти, поэтому разные переменные с одинаковым массивом за содержанием неравны друг другу
// Свойство length - содержит строку, значение длины массива. При изменении массива JS автоматически обновляет значение поля length и оно всегда будет содержать актуальное к-во элементов в массиве

// ФОРМАТ ЗАПИСИ МАССИВОВ
// Пример 1
// Синтаксис с квадратными скобками
const myArray = [1, 2, 3];
console.log(myArray); // [1, 2, 3]

// Пример 2
// Создание масиива путем создания нового экземпляра класса Array
const mySecondArray = new Array(1, 2, 3);
console.log(mySecondArray); // [1, 2, 3]

console.log(myArray.length); // 3

// ОПЕРАТОР СРАВНЕНИЯ ДЛЯ МАССИВОВ И ОБЪЕКТОВ
console.log(myArray === mySecondArray); // false

const myThirdArray = myArray;
// скопировали массив по ссылке

console.log(myArray === myThirdArray); // true
// true так как обе переменные будут ссылаться на один массив в памяти

// МАССИВ ПРОТИВ ОБЪЕКТА
// Визуально массивы и объекты совпадают, такие же свойства (0, 1, 2, ... и length), но разные прототипы и разное поведение
// Для массива прототипом будет массив _proto_: Array(0)
// Для объекта прототипом будет объект _proto_: Object
// Именно прототипы влияют на то, какие методы становятся доступными для объектов и массивов

// Если свойства в объектах цифровые - нельзя использовать точечную запись, поэтому мы и обращаемся к конкретному елементу (свойству) массива через квадратные скобки (доступ к елементам в массиве по их индексу)
console.log(myArray[0]);

// Порядок следования елементов в массиве важен, так как каждый имеет свой порядковый номер - индекс

// МЕТОДЫ МАССИВОВ
// Методы массивов называются функциями высшего порядка либо функциями / методами прототипа

// push - добавление нового элемента в конец массива
myArray.push(true);
console.log(myArray); // (4) [1, 2, 3, true]

// pop - удаление последнего элемента массива. Так же возвращает удаленный элемент, следовательно можно присвоить результат вызова метода pop переменной
myArray.pop();
console.log(myArray); // (3) [1, 2, 3]

const removedElement = myArray.pop();
console.log(removedElement); // 3
console.log(myArray); // (2) [1, 2]

// unshift - добавление элемента в начало массива

// shift - удаление первого элемента массива. Возвращает удаленный элемент.

// Методы push, pop, unshift и shift мутируют оригинальный массив (новый массив не создают )

// МЕТОД forEach
// Аргумент в этом методе - функция (callback ф-ция, которая будет вызвана внутри метода forEach)

// Перебирает все элементы массива и для каждого элемента массива метод forEach будет вызывать callback ф-цию

// Не изменяет оригинальный массив

myArray.forEach((el) => console.log(el * 2));

const hjhj = myArray.forEach((el) => el * 2);
console.log(hjhj); // undefined - в отличии от метода map метод forEach просто выполняет действия с каждым элементом и не формирует новый массив

// МЕТОД map
// Аргумент в этом методе - функция (callback ф-ция, которая будет вызвана внутри метода map)

// Не изменяет оригинальный массив

// Возвращает новый массив (формирует его исходя из рузультатов callback ф-ции)

// Поэтому имеет смысл присваивать результат вызова метода map новой переменной

// Всегда вернет массив той же длины, что и оригинальный массив

const newArray = myArray.map((el) => el * 3);

console.log(myArray); // (2) [1, 2]
console.log(newArray); // (2) [3, 6]

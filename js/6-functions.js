// ФУНКЦИИ

// ОБЩИЕ ПОНЯТИЯ
// ОБЪЯВЛЕНИЕ ФУНКЦИИ
// ВЫЗОВ ФУНКЦИИ
// ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ
// КОЛБЭК ФУНКЦИИ

// ОБЩИЕ ПОНЯТИЯ
// Функция - это блок кода, который можно выполнять многократно
// Функция позволяет выполнять одни и те же действия многократно с разными вводными значениями
// Для этого у неё и присутсвуют параметры. Значения этих параметров (аргументы) меняются в каждом вызове функции. Параметры не меняются
// *: Очень рекомендуется избегать повторений блоков кода, если есть повторения, значит код написан неоптимально, его можно оптимизировать

//  Функция может быть ...
// ... именованной
// ... присвоена переменной
// ... анонимной
// ... аргументом при вызове другой функции (callback функции)
// ... значением свойства (метода) объекта

// Функция - это объект, поэому как у любого объекта у ф-ции есть свойства
function myFn(a, b) {
  let c;
  a = a + 1;
  c = a + b;
  return c;
}

console.dir(myFn);

console.log(myFn(1, 2));

// ОБЪЯВЛЕНИЕ ФУНКЦИИ
// myFn - имя ф-ции
// {...} - между фигурными скобками находится тело ф-ции
// a, b - параметры ф-ции (находятся в скобках при объявлении ф-ции). Параметры ф-ции ведут себя как переменные и в теле ф-ции мы имеем доступ к этим переменным (вне фунции при попытке получить доступ к этим переменным будет ошибка). Значения этих переменных определяются в момент вызова ф-ции (когда мы вызываем ф-цию, мы говорим какие значения хотим присвоить параметрам (переменным) ф-ции)
// return - используется для возвращения результата ф-ции. После интрукции с ключевым словом return ф-ция прекращает выполнение дальнейших инструкций, любые операции после return не будут выполнены. То есть ф-ция возвращает результат и заканчивает свою работу
// Ф-ция возвращает undefined если нет инструкции return

// ВЫЗОВ ФУНКЦИИ
// myFn(10 , 3)
// 10, 3 - аргументы - это те значения, которые мы передаем в вызове функции

console.log("--------------------------------------");

// ПЕРЕДАЧА ЗНАЧЕНИЯ ПО ССЫЛКЕ
const personOne = {
  name: "Bob",
  age: 21,
};

console.log(personOne);
console.log(personOne.age); // 21

function increasePersonAge(person) {
  person.age += 1;
  return person;
} // Ф-ция мутирует внешний объект. Так как personOne и person ссылаются на один и тот же объект в памяти, то соответсвенно personOne так же изменится

increasePersonAge(personOne); // Передача объекта по ссылке (выходит, что мы передаем только ссылку на объект personOne)
// В результате personOne и person будут ссылаться на один объект в памяти
console.log(personOne);
console.log(personOne.age); // 22 - изменился

// ! ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МУТИРОВАТЬ ВНЕШНИЕ ОБЪЕКТЫ ---> ПОЭТОМУ СЛЕДУЕТ СОЗДАВАТЬ КОПИИ ОБЪЕКТА

function increasePersonAge2(person) {
  // const updatedPerson = Object.assign({}, person);
  const updatedPerson = { ...person };
  updatedPerson.age += 1; // не мутируем оригинальный объект
  return updatedPerson;
}

const updatedPersonOne = increasePersonAge2(personOne);
console.log(personOne.age); // 22 - не изменился
console.log(updatedPersonOne.age); // 23

console.log("--------------------------------------");

// КОЛБЭК ФУНКЦИИ
// callback ф-ция - когда одна ф-ция вызывается внутри другой ф-ции

// Пример 1

function anotherFunction() {
  // Действия...
} // просто объявили ф-цию, которая выполняет какие-то действия
// в данном примере anotherFunction - это callback ф-ция

function fnWithCallback(callbackFunction) {
  callbackFunction(); // в теле fnWithCallback мы вызываем ф-цию callbackFunction (колбэк ф-цию)
} // значением параметра callbackFunction будет другая ф-ция (колбэк ф-ция)

fnWithCallback(anotherFunction); // аргументом в вызове fnWithCallback является другая ф-ция anotherFunction

// Пример 2

function printMyName() {
  console.log("Kate");
}

// setTimeout(printMyName, 1000);
// setTimeout - встроенная ф-ция в JS, доступна по умолчанию как один из методов глобального объекта
// внутри себя вызывает ф-цию, которая передана как 1й аргумент
// ф-ция printMyName (callback ф-ция) будет вызвана через 1000 миллисекунд (определенное время - 2й аргумент)

// Правила работы с функциями:
// 1. Называть ф-ции исходя из выполняемых задач
// 2. Одна ф-ция должна выполнять одну задачу
// 3. Не рекомендуется изменять внешние относительно ф-ции переменные

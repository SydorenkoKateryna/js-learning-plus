// ОБЩЕЕ
// Node.js - это среда выполнения JS

// Три ключевых понятия в JS: выражения, функции, объекты

// Практически все сущности в JS - это объекты
// Объект - это набор свойств и у свойст есть свои значения {имя (ключ): значение}
// Масив и функция - это объекты
// Числа и строки - ведут себя как объекты; это примитивные значения

// О CONSOLE
// console.log
// console - это объект
// log - это метод
// Метод - это ф-ция, которая является значением одного из свойст объекта
// . (точка) - это синтаксис JS, точечная запись. С её помощью можно получать доступ к свойстам объекта
// () (скобки) - это вызов метода (вызываем ф-цию log, которая является методом объекта console)

console.log("hello");

// console.dir() - отображает все свойства объетка
// console.table() - отображает все свойства объекта в табличном виде

// ФЦНКЦИЯ
// Функция выполянет какую-то свою задачу и возвращает значение (результат)

// ВЫРАЖЕНИЕ
// Любое выражение возвращает значение
// Выражения - это сроки, числа, переменные, логические выражения, функции (потому что возвращают значение -> результат ф-ции)
// 'abc', 10, 5 + 2, c = 10, 'good' + 'evening', a <= b || c !== d, myFunction(c, d)
// Выражение с побочными действиями - не только возвращает значение, но и выполняет другие действия

console.log("-----------------1---------------------");

// ПЕРЕМЕННЫЕ
// Переменные дают возможность ПОВТОРНОГО доступа к значениям (это как контейнеры для хранения значений)

// ИМЕНА ПЕРЕМЕННЫХ
// PascalCase - типы и классы
// DB_PASSWORD - значения известны до запуска приложения и не меняются (константы)
// camelCase - все остальные переменные

// ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ
// let - можно переприсваивать переменной другие значения; можно сначала объявить переменную, а потом присвоить ей значение (до присвоения значение переменной будет undefined)
// const - нужно в одной строке сразу обьявить и присвоить значение переменной; новое значение нельзя присвоить
// var - присутсвовал в JS с самого начала, не рекомендуется сейчас к использованию

// let и const появились ECMAScript6 (стандарт JS (2015 год), который описывает полностью все ф-ции JS, а уже различные браузеры, node.js применяют этот стандарт)

// let a - объявление
// const c = 10 - объявление и присваивание
// a = true - присваивание

// console.log(a);
// ReferenceError: a is not defined

let a;
console.log(a);
// undefined
a = true;
console.log(a);
// true

console.log("-----------------2---------------------");

// ТИПЫ ПЕРЕМЕНННОЙ
// Тип переменной определяется типом приисвоенного значения

// ТИПЫ
// ПРИМИТИВНЫЕ ТИПЫ: string (строка), boolean (логический), number (число), null (значение отсутствует; можем присвоить самостоятельно, а потом переприсвоить значение), undefined (значения не существует -> неопределено, сами обычно не присваиваем), symbol (символ)
// Примитивные типы - переменная в памяти содержит то или иное значение
// ССЫЛОЧНЫЙ ТИП - object (объект)
// Ссылочный тип - переменная в памяти содержит ссылку на объект, который находится в другом месте (на область в памяти где находится сам объект)

// ОЧИСТКА КОНСОЛИ
// Если мы объявляем переменные (const) непосредственно в консоли, то при попытке их изменить будет ошибка (Assignment to constant variable), так как текущая сессия сохраняет все переменные, которые мы вводили. Чтобы очистить нужно либо закрыть и заново открыть консоль либо нажать Ctrl + R

const objectA = {
  a: 10,
  b: true,
};

console.log(objectA);

const copyOfA = objectA;
// копируем ссылку на объект

console.log(copyOfA);

console.log(objectA === copyOfA);
// true - содержат ссылку на один и тот же объект

copyOfA.c = "abc";
// изменения будут в обоих переменных

console.log(objectA);
console.log(copyOfA);

console.log("-----------------3---------------------");

// ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ
// Статическая типизаци - это когда при объявлении переменной так же указывается тип переменной. Попытка переприсвоить переменной значение другого типа вызовет ошибку.
// Динамическая типизация - в JS нет необходимости указывать тип переменной, когда мы объявляем переменную либо присваиваем ей значение. Можна переприсвоить переменной значение другого типа.
// JAVASCRIPT - динамически типизируемый язык

function d() {
  console.log("Hey there");
}

d();
// Вызов ф-ции, все хорошо

d = 10;
// переменной d присвоили значение типа число

// d();
// Вызов ф-ции, будет ошибка Uncaught TypeError: d is not a function

// const - позволяет предотвратить возможные проблемы связанные с динамической типизацией

const f = () => {
  console.log("Hey there");
};

f();

// f = 10;
// Ошибка будет уже на этом этапе, потому что просваивать новое значение переменным объявленным при помощи const запрещено (TypeError: Assignment to constant variable)

f();
// Выволнение кода не дойдет до этой строки

// Правила работы с переменными
// 1. Все переменные объявлять перед их использованием
// 2. Стараться использовать const везде, где это возможно

console.log("-----------------4---------------------");

// ОБЪЕКТЫ
// Порядок свойств не имеет значения)

const myCity = {
  city: "New York",
  popular: true,
  country: "USA",
};

console.log(myCity);
console.log(myCity.city);
console.log(myCity.popular);
console.log(myCity.country);

console.log("-----------------4.1---------------------");

console.log(Object.keys(myCity));
for (const key of Object.keys(myCity)) {
  console.log(`key: ${key}`);
  console.log(`myCity[key]: ${myCity[key]}`);
  console.log(`typeof(key): ${typeof key}`);
}

console.log("-----------------4.2---------------------");

console.log(Object.values(myCity));
for (const val of Object.values(myCity)) {
  console.log(`val: ${val}`);
  console.log(`typeof(val): ${typeof val}`);
}

console.log("-----------------4.3---------------------");

console.log(Object.entries(myCity));
for (const ent of Object.entries(myCity)) {
  console.log(`ent: ${ent}`);
  console.log(`ent[0] & ent[1]: ${ent[0]}: ${ent[1]}`);
  console.log(`typeof(ent): ${typeof ent}`);
}

myCity.state = "NY";
console.log(myCity);

console.log("-----------------4.4---------------------");

// Удаление свойств (delete)
delete myCity.country;
console.log(myCity);

console.log("-----------------4.5---------------------");

// Доступ к значению свойства с использованием скобок (bracket notation - скобочная запись)
// Чаще всего используется, когда нужно добавить свойство к объекту, которое будет называться так, как значение другой переменной
// В остальных случаях лучше обращаться к свойствам через точку

// myCity['country'] = 'USA';
// console.log(myCity);

const countryPropertyName = "country";

myCity[countryPropertyName] = "USA";
console.log(myCity);

console.log("-----------------4.6---------------------");

// Вложенные свойства

myCity.info = {};
myCity.info.averageTemperature = "24.5°C";
myCity.info.population = 8804190;

console.log(myCity);

delete myCity.info["averageTemperature"];
console.log(myCity);
delete myCity.info.population;
console.log(myCity);
// После удаления всех свойств с info все еще остается просто пустой объект info
delete myCity.info;
console.log(myCity);

console.log("-----------------4.7---------------------");
// Использование переменных & сокращенный формат записи свойст (имя(ключ) = значение)
// Сокращенный свойства рекомендуется размещать в начале объекта

const name = "Kate";
const postsQty = 21;

const userProfile = {
  // name: name,
  name,
  // postsQty: postsQty,
  postsQty,
  hasSignedAgreement: false,
};

console.log(userProfile);

// ГЛОБАЛЬНЫЕ ОБЪЕКТЫ
// window - присутствует в Веб-браузерах
// В объекте window присутсвуют методы и свойства, которые доступны в веб-браузере по умолчанию -> можем их использовать

// global - присутсвует в Node.js

// УНИФИЦИРОВАННЫЙ (единый) ГЛОБАЛЬНЫЙ ОБЪЕКТ
// globalThis - доступен уже во всех Веб-браузерах и Node.js

// console - это одно из свойств глобального объекта window и global
// console.log === window.console.log === globalThis.console.log
// console.log === global.console.log === globalThis.console.log

console.log("-----------------4.8---------------------");
// МЕТОДЫ ОБЪЕКТА
// Метод - это свойство объекта, значение которого функция

// const myCity = {
//  cityGreeting: function () {
//      console.log('Greetings!')
//  }
// }

// const myCity = {
//  cityGreeting() {
//      console.log('Greetings!')
//  }
// }

myCity.cityGreeting = function () {
  console.log(`Greetings to ${this.city}`);
};

// myCity.cityGreeting = () => console.log(`Greetings to ${this.city}`);
// будет ошибка, так как в стрелочных нет this, поэтому для записи методов объекта они плохо подходять

console.log(myCity);
console.log(myCity.cityGreeting());

console.log("-----------------5---------------------");

// JSON - JAVASCRIPT OBJECT NOTATION
// Формат обмена данными (передачи данных) между компьютерами в интернете
// Данные передаются ввиде строки

// Конвертация JSON в объект (parse - метод объекта JSON)
// Ф-ция JSON.parse()

// Конвертация объекта в JSON (stringify - метод объекта JSON)
// Ф-ция JSON.stringify()

console.log("-----------------6---------------------");

// МУТАЦИЯ В JAVASCRIPT
// Копирование примитивных типов происходит по значению (copy by value)
// При изменении / добавлении свойст в объект происходит мутация объекта на который ссылается переменная
// Копирование сложных типов происходит по ссылке (copy by reference)
// Мутирование копий (мутирование объекта через копию) - когда несколько переменных ссылаются на один объект в памяти, мы можем менять значения свойств объекта через все эти переменные

// КАК ИЗБЕЖАТЬ МУТАЦИЙ

// При следующих подходах  в objectB будет лежать новая ссылка на новый объект, то есть objectB !== objectA
// При изменении свойств в новом объекте, мутации оригинального объекта не происходит

console.log("-----------------6.1---------------------");

// Вариант 1
// Частичная мутация
// assign - метод объекта Object
// Object - является частью глобального объекта (свойство глобального объекта), доступен как в Веб-браузерах, так и в Node.js
// const objectB = Object.assign({}, objectA)
// Проблематика: если у объекта есть вложенные объекты, то ссылки на них сохраняются, то есть мы избегаем мутации только корневых свойств объекта

const person = {
  name: "Bob",
  age: 25,
};

const person2 = Object.assign({}, person);

person2.age = 26;

console.log(person.age); // 25
console.log(person2.age); // 26

console.log("-----------------6.2---------------------");

// Вариант 2
// Частичная мутация
// Оператор spread - оператор разделения объекта на свойства
// Берется объект objectA и разделяется на свойства, а потом эти свойства сразу же собираются в новый объект objectB, так как указаны фигурные скобки
// Проблематика: если у объекта есть вложенные объекты, то ссылки на них сохраняются, то есть мы избегаем мутации только корневых свойств объекта

const person3 = { ...person };

person3.name = "Alis";

console.log(person.name); // Bob
console.log(person3.name); // Alis

console.log("-----------------6.3---------------------");

// Вариант 3
// Полностью избегаем мутации
// Ссылки на вложенные объекты не сохраняются
// 1 етап - конвертируем objectA в строку с помощью метода stringify
// 2 етап - полученую строку передаем как аргумент в вызове метода parse, то есть конвертируем строку обратно в объект

const person4 = JSON.parse(JSON.stringify(person));

console.log(JSON.stringify(person)); // {"name":"Bob","age":25}
console.log(JSON.parse(JSON.stringify(person))); // {name: 'Bob', age: 25}

person4.name = "Jonson";

console.log(person.name); // Bob
console.log(person4.name); // Jonson

console.log("-----------------7---------------------");

// ФУНКЦИИ
// Функция - это блок кода, который можно выполнять многократно
// Функция позволяет выполнять одни и те же действия многократно с разными вводными значениями
// Для этого у неё и присутсвуют параметры. Значения этих параметров (аргументы) меняются в каждом вызове функции. Параметры не меняются
// *: Очень рекомендуется избегать повторений блоков кода, если есть повторения, значит код написан неоптимально, его можно оптимизировать

//  Функция может быть ...
// ... именованной
// ... присвоена переменной
// ... анонимной
// ... аргументом при вызове другой функции (callback функции)
// ... значением свойства (метода) объекта

// Функция - это объект, поэому как у любого объекта у ф-ции есть свойства
function myFn(a, b) {
  let c;
  a = a + 1;
  c = a + b;
  return c;
}

console.dir(myFn);

console.log(myFn(1, 2));

// Объявление функции
// myFn - имя ф-ции
// {...} - между фигурными скобками находится тело ф-ции
// a, b - параметры ф-ции (находятся в скобках при объявлении ф-ции). Параметры ф-ции ведут себя как переменные и в теле ф-ции мы имеем доступ к этим переменным (вне фунции при попытке получить доступ к этим переменным будет ошибка). Значения этих переменных определяются в момент вызова ф-ции (когда мы вызываем ф-цию, мы говорим какие значения хотим присвоить параметрам (переменным) ф-ции)
// return - используется для возвращения результата ф-ции. После интрукции с ключевым словом return ф-ция прекращает выполнение дальнейших инструкций, любые операции после return не будут выполнены. То есть ф-ция возвращает результат и заканчивает свою работу
// Ф-ция возвращает undefined если нет инструкции return

// Вызов ф-ции
// myFn(10 , 3)
// 10, 3 - аргументы - это те значения, которые мы передаем в вызове функции

console.log("-----------------7.1---------------------");

// Передача значения по ссылке
const personOne = {
  name: "Bob",
  age: 21,
};

console.log(personOne);
console.log(personOne.age); // 21

function increasePersonAge(person) {
  person.age += 1;
  return person;
} // Ф-ция мутирует внешний объект. Так как personOne и person ссылаются на один и тот же объект в памяти, то соответсвенно personOne так же изменится

increasePersonAge(personOne); // Передача объекта по ссылке (выходит, что мы передаем только ссылку на объект personOne)
// В результате personOne и person будут ссылаться на один объект в памяти
console.log(personOne);
console.log(personOne.age); // 22 - изменился

// ! ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МУТИРОВАТЬ ВНЕШНИЕ ОБЪЕКТЫ ---> ПОЭТОМУ СЛЕДУЕТ СОЗДАВАТЬ КОПИИ ОБЪЕКТА

function increasePersonAge2(person) {
  // const updatedPerson = Object.assign({}, person);
  const updatedPerson = { ...person };
  updatedPerson.age += 1; // не мутируем оригинальный объект
  return updatedPerson;
}

const updatedPersonOne = increasePersonAge2(personOne);
console.log(personOne.age); // 22 - не изменился
console.log(updatedPersonOne.age); // 23

console.log("-----------------7.2---------------------");

// Колбэк функции
// callback ф-ция - когда одна ф-ция вызывается внутри другой ф-ции

// Пример 1

function anotherFunction() {
  // Действия...
} // просто объявили ф-цию, которая выполняет какие-то действия
// в данном примере anotherFunction - это callback ф-ция

function fnWithCallback(callbackFunction) {
  callbackFunction(); // в теле fnWithCallback мы вызываем ф-цию callbackFunction (колбэк ф-цию)
} // значением параметра callbackFunction будет другая ф-ция (колбэк ф-ция)

fnWithCallback(anotherFunction); // аргументом в вызове fnWithCallback является другая ф-ция anotherFunction

// Пример 2

function printMyName() {
  console.log("Kate");
}

// setTimeout(printMyName, 1000);
// setTimeout - встроенная ф-ция в JS, доступна по умолчанию как один из методов глобального объекта
// внутри себя вызывает ф-цию, которая передана как 1й аргумент
// ф-ция printMyName (callback ф-ция) будет вызвана через 1000 миллисекунд (определенное время - 2й аргумент)

// Правила работы с функциями:
// 1. Называть ф-ции исходя из выполняемых задач
// 2. Одна ф-ция должна выполнять одну задачу
// 3. Не рекомендуется изменять внешние относительно ф-ции переменные

console.log("-----------------8---------------------");

// ОБЛАСТИ ВИДИМОСТИ
// Область видимости определяет границы действия переменной

// Глобальные переменные - объявлены в глобальной области видимости (window, global, console ...)
// Локальные переменные - объявлены в локальных областях видимости

const x = 5;

function myFunction() {
  function innerFn() {
    console.log(x);
  }
  innerFn();
}

myFunction();

// Цепочка областей видимости: х? {innerFn scope} -> {myFn scope} -> {Global scope} ---> нашли х в глобальной области видимости

// Вызов innerFn() в глобальной области видимости вызовет ошибку, так как эта ф-ция объявлена в локальной области видимости ф-ции myFunction()

console.log("-----------------9---------------------");

// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННЫХ
let j; // 1.а. Обяъвление "j" в глобальной области видимости ( = undefined)
let g; // 1.б. Обяъвление "g" в глобальной области видимости ( = undefined)

function myF() {
  let g; // 3.б. Объявление "g" в зоне видимости ф-ции
  j = true; // 3.а. Объявлена ли "j" в зоне видимости ф-ции? НЕТ. Объявлена ли "j" во внешней области видимости? ДА. Присваивание значение true глобальной переменной "j"
  g = 10; // 4.б. Объявлена ли "g" в зоне видимости ф-ции? ДА. Присвоение этой переменной "g" значения 10
  console.log(j); // true
  console.log(g); // 10 - 5.б. "g" имеет значение 10 в области видимости ф-ции
}

myF(); // 2.а. и 2.б. Вызов myF

console.log(j); // true - 4.а. "j" имеет значение true
console.log(g); // undefined - 6.б. "g" всё так же имеет значение undefined в глобальной области

console.log("-----------------10---------------------");

// ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ
// 1. Глобальная область видимости
// 2. Область видимости ф-ции - создаются каждый раз, когда мы вызываем ту или иную ф-цию, то есть для каждой ф-ции, для каждого вызова ф-ции такая область будет своя
// 3. Область видимости блока - переменные, объявленные с помощью let или const внутри блока имеют область видимости, ограниченную этим блоком
// *: Блок в JS - это любой код, который находится между фигурными скобками
// *: Необъявленные переменные (без let или const) будут автоматически объявлены в глобальной области видимости, то есть доступ к таким переменным будет без ошибки в любой области видимости и это плохо

// Правила работы с переменными
// 1. Все переменные объявлять перед их использованием
// 2. Стараться использовать const везде, где это возможно
// 3. Внутри функций не изменять переменные с внешних областей видимости

// Строгий режим - это инструкция для JS анализировать наш код более пристально. Запрещает использование необъявленных переменных.
// 1 вариант: строка 'use strict' - должна быть первой в глобальной области видимости или в области видимости ф-ции
// 2 вариант - указать в скрипте type='module'

console.log("-----------------11---------------------");

// ОПЕРАТОРЫ
// Оператор - это встроенная (внутренняя) функция
// Операнды (аргументы) - это то, что стоит слева и справа от оператора
// Операторы бывают:
// 1. Арифметические: +, -, *, /
// 2. Сравнения: ===, !==, <=, >=
// 3. Логические: !, &&, ||
// 4. Присваивания: =
// 5. Текстовые: typeof (проверить тип значения, рузалатом будет строка с типом значения), instanceof (проверить принадлежность объекта тому или иному класу), new, delete (удалить свойство в объекте)

// Оператор присваивания
// function =(переменная, выражение) {
// 1. Получение результата выражения
// 2. Поиск переменной по имени
// 3. Присваивание результата выражения переменной
// 4. Возврат результата выражения
// }

// Унарные и бинарные операторы
// Унарные операторы - у них всегда один операнд (аргумент): а++, +а, delete obj.a, typeof a, new Object()
// Бинарные операторы - у них всегда два операнда (аргумента): a = 5, a + b, a += 5, a === b, a && b

// Форматы записи операторов
// Инфиксная запись - оператор находится между операндами: a = true, a + b, a += 5, a || b, a > b
// Префиксная запись - оператор стоит перед операндом: ++а, delete obj.a, typeof a
// Постфиксная запись - оператор идет за операндом: а++, myFunction() - круглые скобки это тоже оператор в JS, то есть имя ф-ции это операнд

// Приоритетность операторов
// Работают правила с курса математики в средней школе ^-^
// Можно добавить круглые скобки для изменения приоритетности выполнения или для большей наглядности

// Логические операторы
// ! - НЕ - всегда возвращает значение типа boolean независимо от значения операнда
// && - И - возвращает значение одного из операндов
// || - ИЛИ - возвращает значение одного из операндов

// Ложные значения
// Это те значения, который при привидении к логическому типу boolean дают false. Если получаем true, значение неложное, оно истинное
// Boolean(value) ---> false
console.log(Boolean(false)); // false
console.log(Boolean(0)); // false
console.log(Boolean("")); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(null)); // false

// Практика с typeof оператором
console.log(typeof "Kate"); // 'string'
console.log(typeof false); // 'boolean'
console.log(typeof 0); // 'number'
console.log(typeof 10 === "number"); // true

let isUndefined;
console.log(typeof isUndefined === "undefined"); // true

// Оператор НЕ (оператор отрицания)
// Оператор ! чаще всего используется в условных инструкциях (if, if else и т.д.)
console.log(!10); // false
console.log(!0); // true
// Отрицание отрицания !! позволяет проверить ложность значения
console.log(!!10); // true
console.log(!!0); // false

const emptyObject = {};

console.log(!!emptyObject); // true

// Операторы короткого замыкания И
// Оператор И (&&) требует правдивости обоих операндов (ищет первое ложное значение)
// Выражение 1 && Выражение 2
// Если "Выражение 1" ложно: "Выражение 2" игнорируется; возвращается результат "Выражения 1"
// Если "Выражение 1" истинно -> оценивается "Выражение 2"
// Если "Выражение 2" ложно: возвращается результат "Выражения 2"
// Если "Выражение 2" истинно: возвращается результат "Выражения 2"

// Оператор короткого замыкания ИЛИ
// Оператор ИЛИ (||) требует правдивости одного из операндов (ищет первое истинное значение)
// Выражение 1 || Выражение 2
// Если "Выражение 1" истинно: "Выражение 2" игнорируется; возвращается результат "Выражения 1"
// Если "Выражение 1" ложно -> оценивается "Выражение 2"
// Если "Выражение 2" ложно: возвращается результат "Выражения 2"
// Если "Выражение 2" истинно: возвращается результат "Выражения 2"

console.log(0 & undefined); // 0
console.log(0 & 5); // 0
console.log(0 || undefined); // undefined
console.log(0 || 5); // 5
console.log(5 || undefined); // 5
console.log(5 || (undefined && 0)); // 5
console.log((5 || undefined) && 0); // 0

// Трюк с оператором И и вызовом функции
let y = 10;
y && console.log("Выполнено!"); // Выполнено!

let r;
r && console.log("Выполнено!"); // undefined
// На месте console.log может быть любая ф-ция. С помощью такого подхода можно условно вызывать те или иные ф-ции, вызывать в зависимости от того, какие значения есть у тех или других переменных

console.log("-----------------12.1---------------------");

// Оператор разделения объекта на свойства
// Оператор ... (три точки, spread) - это префексный и унарный оператор
const button = {
  width: 200,
  text: "Buy",
};

const redButton = {
  ...button, // разделяем объект button на свойства
  color: "red", // если у объекта button есть свойство color, его значение будет перезаписано на новое, если color идет после распыления, а если color идет до распыление, перезапишется значение свойства с исходного объекта
};

console.table(redButton);

console.log("-----------------12.2---------------------");

// Объединение объектов с помощью ...
// Порядок передачи данных важен, так как одинаковые свойства будут перезаписаны
const buttonInfo = {
  text: "Buy",
};

const buttonStyle = {
  color: "yellow",
  width: 200,
  height: 300,
};

const newButton = {
  ...buttonInfo,
  ...buttonStyle,
};

console.table(newButton);

console.log("-----------------13---------------------");

// КОНКАТЕНАЦИЯ СТРОК (соединение строк)
console.log("Hello " + "World");

const hello = "Hello";
const world = "World";

const greeting = hello + " " + world;
console.log(greeting);

// ШАБЛОННЫЕ СТРОКИ
const newGreeting = `${hello} ${world}`;
console.log(newGreeting);

// Нужно помнить об автоматической конвертации типов (привидении типов) интерпретатором JS, если мы соединяем число и строку, то на выходе получим строку, поэтому всегда нужно четко понимать, какие типы у значений/переменных, которые мы хотим соединить

console.log("-----------------14---------------------");

// ФУНКЦИОНАЛЬНЫЕ ВЫРАЖЕНИЯ
// Объявленная функция - когда мы объявляем ф-цию, создается переменная с именем, а значением этой переменной будет ф-ция и эту ф-цию можно вызвать написав имя и поставим после этого ()
function myNewFn(a, b) {
  let c;
  a = a + 1;
  c = a + b;
  return c;
}

myNewFn(2, 4);
console.log(myNewFn(2, 4)); // 7

// !!! При таком объявлении ф-ции можно переприсвоить значение - это не хорошо
myNewFn = 10;
console.log(myNewFn); // 10

// Функциональное выражение - у него нет имени и сразу после ключевого слова function идут параметры в скобках
// function(a, b) {
//   let c;
//   a = a + 1;
//   c = a + b;
//   return c;
// }

// Функциональные выражения ВСЕГДА АНОНИМНЫЕ
// Функциональные выражения нельзя использовать автономно
// Так же как и объявленную ф-цию, функциональные выражения можно:
// 1. присваивать переменной
// 2. использовать как аргумент (callback) в вызове другой ф-ции

console.log("-----------------14.1---------------------");

// Пример 1: Присвоение функционального выражения перменной
const myNewFunction = function (a, b) {
  let c;
  a = a + 1;
  c = a + b;
  return c;
};
// myNewFunction - это переменная
// function (a, b) {...} - с этого момента начинается функция (анонимное функциональное выражение)
// То есть мы присваиваем переменной myNewFunction функциональное выражение
// У функционального выражения нет имени, но путем присвоения функционального выражения переменной мы даем имя такому функциональному выражению и после этого мы можем вызывать такое функциональное выражение, как любую другую функцию, обращаясь к имени переменной

myNewFunction(5, 3);
console.log(myNewFunction(5, 3)); // 9

console.log("-----------------14.2---------------------");

// Пример 2: Функциональное выражени в вызове другой функции
// setTimeout(function() {
//   console.log('Отложенное сообщение')
// }, 1000);

console.log("-----------------15---------------------");

// СТРЕЛОЧНЫЕ ФУНКЦИИ
// Нет ключевого слова function
// Нет имени
// Начинается сразу же с параметров или ()
// Всегда анонимные
// Стрелочная функция - это выражение
// Имя стрелочной функции дается путем присваивания переменной

const myNewNewFunction = (a, b) => {
  let c;
  a = a + 1;
  c = a + b;
  return c;
};

myNewNewFunction(4, 11);
console.log(myNewNewFunction(4, 11)); // 16

// !!! Лучше присваивать стрелочную ф-цию либо функциональное выражение переменным const, чем объявлять ф-цию с помощью function, так как таким образом мы предотвращаем возможную ситуацию присвоения нового значения переменным

// Стрелочная ф-ция как callback
// setTimeout(() => {
//   console.log('Отложенное сообщение')
// }, 1000);

// Сокращение в стрелочных функциях
// 1. Если один параметр, то круглые скобки можно опустить
// a => {
// Тело функции
// }
// 2. Фигурные скобки можно опустить если тело функции состоит из одного выражения
// (a, b) => a + b
// В этом случае стрелочая ф-ция НЕЯВНО возвращает результат выражения

console.log("-----------------16---------------------");

// ЗНАЧЕНИЯ ПАРАМЕТРОВ ФУНКЦИИ ПО УМОЛЧАНИЮ
// Значения по умолчанию вычисляются в момент вызова функции

// Пример 1
// function multByFactor(value, multiplier = 1) {
//   return value * multiplier;
// }

// --->

// const multByFactor = function(value, multiplier = 1) {
//   return value * multiplier;
// }

// --->

// const multByFactor = (value, multiplier = 1) => {
//   return value * multiplier;
// }

// --->

const multByFactor = (value, multiplier = 1) => value * multiplier;
// Параметру multiplier присвоено дефолтное значение в описании паараметров ф-ции. Если значения для параметра multiplier не будет передано в вызове ф-ции, то ему присвоится значение по умолчанию
console.log(multByFactor(10, 2)); //  20
console.log(multByFactor(5)); // 5

// Пример 2

// const newPost = (post, addedAt = Date()) => {
//   return {...post, addedAt};
//  };

const newPost = (post, addedAt = Date()) => ({ ...post, addedAt });
// Date() - встроенная ф-ция, возвращает строку с текущей датой
// Если мы хотим неявно вернуть объект, то нужно обернуть его в круглые скобки, иначе интерпретатор подумает, что это тело ф-ции и будет ошибка

const firstPost = {
  id: 1,
  author: "Kate",
};

console.log(newPost(firstPost)); // {id: 1, author: 'Kate', addedAt: 'Wed Mar 01 2023 19:27:13 GMT+0200 (за східноєвропейським стандартним часом)'}
// В момент вызова ф-ции происходит присваивание параметру addedAt значения по умолчанию

console.log("-----------------17---------------------");

// ОБРАБОТКА ОШИБОК
// Uncaught Error - непойманая ошибка

const fnWithError = () => {
  throw new Error("Some error");
};
// С помощью инструкции throw new Error мы можем згенерировать ошибку в JS

// fnWithError(); // Uncaught Error: Some error

// console.log('Continue...')

// Выполнение кода остановится после появления Uncaught Error, до console.log интерпретатор не дойдет

// КАК "ЛОВИТЬ" Uncaught Error?
// Решение - специальный синтаксис TRY/CATCH, который состоит с двух блоков кода

try {
  // Выполнение блока кода
  // Сюда помещается часть кода, в которой вероятно возникновение ошибок
} catch (error) {
  // Этот блок выполняется в случае возникновения ошибок в блоке try
  // Внутри этого блока будет доступ к переменной, которая содержит ошибку возникшую в блоке try
}

const newFnWithError = () => {
  throw new Error("Some error");
};

try {
  newFnWithError(); // возникнет ошибка и эта ошибка будет присвоена как значение переменной error в блоке catch
} catch (error) {
  console.error(error); // вывод ошибки в консоль в её стандартном виде. В данном случае ошибка будет поймана, слова Uncaught мы не увидим
  console.log(error.message); // ошибка по сути это объект и у нее есть свойство message. В данном примере message равно "Some error"
}

console.log("Continue..."); // выполнение кода продолжится, интерпретатор дойдет до console.log

// Ошибки можно логировать используя какие-то внешние сервера, чтобы потом позже можно было проанализировать какие ошибки и когда возникали

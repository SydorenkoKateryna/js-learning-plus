// ОБЩЕЕ
// Node.js - это среда выполнения JS

// Три ключевых понятия в JS: выражения, функции, объекты

// Практически все сущности в JS - это объекты
// Объект - это набор свойств и у свойст есть свои значения {имя (ключ): значение}
// Масив и функция - это объекты
// Числа и строки - ведут себя как объекты; это примитивные значения

// О CONSOLE
// console.log
// console - это объект
// log - это метод
// Метод - это ф-ция, которая является значением одного из свойст объекта
// . (точка) - это синтаксис JS, точечная запись. С её помощью можно получать доступ к свойстам объекта
// () (скобки) - это вызов метода (вызываем ф-цию log, которая является методом объекта console)

console.log("hello");

// console.dir() - отображает все свойства объетка
// console.table() - отображает все свойства объекта в табличном виде

// ФЦНКЦИЯ
// Функция выполянет какую-то свою задачу и возвращает значение (результат)

// ВЫРАЖЕНИЕ
// Любое выражение возвращает значение
// Выражения - это сроки, числа, переменные, логические выражения, функции (потому что возвращают значение -> результат ф-ции)
// 'abc', 10, 5 + 2, c = 10, 'good' + 'evening', a <= b || c !== d, myFunction(c, d)
// Выражение с побочными действиями - не только возвращает значение, но и выполняет другие действия

console.log("-----------------1---------------------");

// ПЕРЕМЕННЫЕ
// Переменные дают возможность ПОВТОРНОГО доступа к значениям (это как контейнеры для хранения значений)

// ИМЕНА ПЕРЕМЕННЫХ
// PascalCase - типы и классы
// DB_PASSWORD - значения известны до запуска приложения и не меняются (константы)
// camelCase - все остальные переменные

// ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ
// let - можно переприсваивать переменной другие значения; можно сначала объявить переменную, а потом присвоить ей значение (до присвоения значение переменной будет undefined)
// const - нужно в одной строке сразу обьявить и присвоить значение переменной; новое значение нельзя присвоить
// var - присутсвовал в JS с самого начала, не рекомендуется сейчас к использованию

// let и const появились ECMAScript6 (стандарт JS (2015 год), который описывает полностью все ф-ции JS, а уже различные браузеры, node.js применяют этот стандарт)

// let a - объявление
// const c = 10 - объявление и присваивание
// a = true - присваивание

// console.log(a);
// ReferenceError: a is not defined

let a;
console.log(a);
// undefined
a = true;
console.log(a);
// true

console.log("-----------------2---------------------");

// ТИПЫ ПЕРЕМЕНННОЙ
// Тип переменной определяется типом приисвоенного значения

// ТИПЫ
// ПРИМИТИВНЫЕ ТИПЫ: string (строка), boolean (логический), number (число), null (значение отсутствует; можем присвоить самостоятельно, а потом переприсвоить значение), undefined (значения не существует -> неопределено, сами обычно не присваиваем), symbol (символ)
// Примитивные типы - переменная в памяти содержит то или иное значение
// ССЫЛОЧНЫЙ ТИП - object (объект)
// Ссылочный тип - переменная в памяти содержит ссылку на объект, который находится в другом месте (на область в памяти где находится сам объект)

// ОЧИСТКА КОНСОЛИ
// Если мы объявляем переменные (const) непосредственно в консоли, то при попытке их изменить будет ошибка (Assignment to constant variable), так как текущая сессия сохраняет все переменные, которые мы вводили. Чтобы очистить нужно либо закрыть и заново открыть консоль либо нажать Ctrl + R

const objectA = {
  a: 10,
  b: true,
};

console.log(objectA);

const copyOfA = objectA;
// копируем ссылку на объект

console.log(copyOfA);

console.log(objectA === copyOfA);
// true - содержат ссылку на один и тот же объект

copyOfA.c = "abc";
// изменения будут в обоих переменных

console.log(objectA);
console.log(copyOfA);

console.log("-----------------3---------------------");

// ДИНАМИЧЕСКАЯ ТИПИЗАЦИЯ
// Статическая типизаци - это когда при объявлении переменной так же указывается тип переменной. Попытка переприсвоить переменной значение другого типа вызовет ошибку.
// Динамическая типизация - в JS нет необходимости указывать тип переменной, когда мы объявляем переменную либо присваиваем ей значение. Можна переприсвоить переменной значение другого типа.
// JAVASCRIPT - динамически типизируемый язык

function d() {
  console.log("Hey there");
}

d();
// Вызов ф-ции, все хорошо

d = 10;
// переменной d присвоили значение типа число

// d();
// Вызов ф-ции, будет ошибка Uncaught TypeError: d is not a function

// const - позволяет предотвратить возможные проблемы связанные с динамической типизацией

const f = () => {
  console.log("Hey there");
};

f();

// f = 10;
// Ошибка будет уже на этом этапе, потому что просваивать новое значение переменным объявленным при помощи const запрещено (TypeError: Assignment to constant variable)

f();
// Выволнение кода не дойдет до этой строки

// Правила работы с переменными
// 1. Все переменные объявлять перед их использованием
// 2. Стараться использовать const везде, где это возможно

console.log("-----------------4---------------------");

// ОБЪЕКТЫ
// Порядок свойств не имеет значения)

const myCity = {
  city: "New York",
  popular: true,
  country: "USA",
};

console.log(myCity);
console.log(myCity.city);
console.log(myCity.popular);
console.log(myCity.country);

console.log("-----------------4.1---------------------");

console.log(Object.keys(myCity));
for (const key of Object.keys(myCity)) {
  console.log(`key: ${key}`);
  console.log(`myCity[key]: ${myCity[key]}`);
  console.log(`typeof(key): ${typeof key}`);
}

console.log("-----------------4.2---------------------");

console.log(Object.values(myCity));
for (const val of Object.values(myCity)) {
  console.log(`val: ${val}`);
  console.log(`typeof(val): ${typeof val}`);
}

console.log("-----------------4.3---------------------");

console.log(Object.entries(myCity));
for (const ent of Object.entries(myCity)) {
  console.log(`ent: ${ent}`);
  console.log(`ent[0] & ent[1]: ${ent[0]}: ${ent[1]}`);
  console.log(`typeof(ent): ${typeof ent}`);
}

myCity.state = "NY";
console.log(myCity);

console.log("-----------------4.4---------------------");

// Удаление свойств (delete)
delete myCity.country;
console.log(myCity);

console.log("-----------------4.5---------------------");

// Доступ к значению свойства с использованием скобок (bracket notation - скобочная запись)
// Чаще всего используется, когда нужно добавить свойство к объекту, которое будет называться так, как значение другой переменной
// В остальных случаях лучше обращаться к свойствам через точку

// myCity['country'] = 'USA';
// console.log(myCity);

const countryPropertyName = "country";

myCity[countryPropertyName] = "USA";
console.log(myCity);

console.log("-----------------4.6---------------------");

// Вложенные свойства

myCity.info = {};
myCity.info.averageTemperature = "24.5°C";
myCity.info.population = 8804190;

console.log(myCity);

delete myCity.info["averageTemperature"];
console.log(myCity);
delete myCity.info.population;
console.log(myCity);
// После удаления всех свойств с info все еще остается просто пустой объект info
delete myCity.info;
console.log(myCity);

console.log("-----------------4.7---------------------");
// Использование переменных & сокращенный формат записи свойст (имя(ключ) = значение)
// Сокращенный свойства рекомендуется размещать в начале объекта

const name = "Kate";
const postsQty = 21;

const userProfile = {
  // name: name,
  name,
  // postsQty: postsQty,
  postsQty,
  hasSignedAgreement: false,
};

console.log(userProfile);

// ГЛОБАЛЬНЫЕ ОБЪЕКТЫ
// window - присутствует в Веб-браузерах
// В объекте window присутсвуют методы и свойства, которые доступны в веб-браузере по умолчанию -> можем их использовать

// global - присутсвует в Node.js

// УНИФИЦИРОВАННЫЙ (единый) ГЛОБАЛЬНЫЙ ОБЪЕКТ
// globalThis - доступен уже во всех Веб-браузерах и Node.js

// console - это одно из свойств глобального объекта window и global
// console.log === window.console.log === globalThis.console.log
// console.log === global.console.log === globalThis.console.log

console.log("-----------------4.8---------------------");
// МЕТОДЫ ОБЪЕКТА
// Метод - это свойство объекта, значение которого функция

// const myCity = {
//  cityGreeting: function () {
//      console.log('Greetings!')
//  }
// }

// const myCity = {
//  cityGreeting() {
//      console.log('Greetings!')
//  }
// }

myCity.cityGreeting = function () {
  console.log(`Greetings to ${this.city}`);
};

// myCity.cityGreeting = () => console.log(`Greetings to ${this.city}`);
// будет ошибка, так как в стрелочных нет this, поэтому для записи методов объекта они плохо подходять

console.log(myCity);
console.log(myCity.cityGreeting());

console.log("-----------------5---------------------");

// JSON - JAVASCRIPT OBJECT NOTATION
// Формат обмена данными (передачи данных) между компьютерами в интернете
// Данные передаются ввиде строки

// Конвертация JSON в объект (parse - метод объекта JSON)
// Ф-ция JSON.parse()

// Конвертация объекта в JSON (stringify - метод объекта JSON)
// Ф-ция JSON.stringify()

console.log("-----------------6---------------------");

// МУТАЦИЯ В JAVASCRIPT
// Копирование примитивных типов происходит по значению (copy by value)
// При изменении / добавлении свойст в объект происходит мутация объекта на который ссылается переменная
// Копирование сложных типов происходит по ссылке (copy by reference)
// Мутирование копий (мутирование объекта через копию) - когда несколько переменных ссылаются на один объект в памяти, мы можем менять значения свойств объекта через все эти переменные

// КАК ИЗБЕЖАТЬ МУТАЦИЙ

// При следующих подходах  в objectB будет лежать новая ссылка на новый объект, то есть objectB !== objectA
// При изменении свойств в новом объекте, мутации оригинального объекта не происходит

console.log("-----------------6.1---------------------");

// Вариант 1
// Частичная мутация
// assign - метод объекта Object
// Object - является частью глобального объекта (свойство глобального объекта), доступен как в Веб-браузерах, так и в Node.js
// const objectB = Object.assign({}, objectA)
// Проблематика: если у объекта есть вложенные объекты, то ссылки на них сохраняются, то есть мы избегаем мутации только корневых свойств объекта

const person = {
  name: "Bob",
  age: 25,
};

const person2 = Object.assign({}, person);

person2.age = 26;

console.log(person.age); // 25
console.log(person2.age); // 26

console.log("-----------------6.2---------------------");

// Вариант 2
// Частичная мутация
// Оператор spread - оператор разделения объекта на свойства
// Берется объект objectA и разделяется на свойства, а потом эти свойства сразу же собираются в новый объект objectB, так как указаны фигурные скобки
// Проблематика: если у объекта есть вложенные объекты, то ссылки на них сохраняются, то есть мы избегаем мутации только корневых свойств объекта

const person3 = { ...person };

person3.name = "Alis";

console.log(person.name); // Bob
console.log(person3.name); // Alis

console.log("-----------------6.3---------------------");

// Вариант 3
// Полностью избегаем мутации
// Ссылки на вложенные объекты не сохраняются
// 1 етап - конвертируем objectA в строку с помощью метода stringify
// 2 етап - полученую строку передаем как аргумент в вызове метода parse, то есть конвертируем строку обратно в объект

const person4 = JSON.parse(JSON.stringify(person));

console.log(JSON.stringify(person)); // {"name":"Bob","age":25}
console.log(JSON.parse(JSON.stringify(person))); // {name: 'Bob', age: 25}

person4.name = "Jonson";

console.log(person.name); // Bob
console.log(person4.name); // Jonson

console.log("-----------------7---------------------");

// ФУНКЦИИ
// Функция - это блок кода, который можно выполнять многократно
// Функция позволяет выполнять одни и те же действия многократно с разными вводными значениями
// Для этого у неё и присутсвуют параметры. Значения этих параметров (аргументы) меняются в каждом вызове функции. Параметры не меняются
// *: Очень рекомендуется избегать повторений блоков кода, если есть повторения, значит код написан неоптимально, его можно оптимизировать

//  Функция может быть ...
// ... именованной
// ... присвоена переменной
// ... анонимной
// ... аргументом при вызове другой функции (callback функции)
// ... значением свойства (метода) объекта

// Функция - это объект, поэому как у любого объекта у ф-ции есть свойства
function myFn(a, b) {
  let c;
  a = a + 1;
  c = a + b;
  return c;
}

console.dir(myFn);

console.log(myFn(1, 2));

// Объявление функции
// myFn - имя ф-ции
// {...} - между фигурными скобками находится тело ф-ции
// a, b - параметры ф-ции (находятся в скобках при объявлении ф-ции). Параметры ф-ции ведут себя как переменные и в теле ф-ции мы имеем доступ к этим переменным (вне фунции при попытке получить доступ к этим переменным будет ошибка). Значения этих переменных определяются в момент вызова ф-ции (когда мы вызываем ф-цию, мы говорим какие значения хотим присвоить параметрам (переменным) ф-ции)
// return - используется для возвращения результата ф-ции. После интрукции с ключевым словом return ф-ция прекращает выполнение дальнейших инструкций, любые операции после return не будут выполнены. То есть ф-ция возвращает результат и заканчивает свою работу
// Ф-ция возвращает undefined если нет инструкции return

// Вызов ф-ции
// myFn(10 , 3)
// 10, 3 - аргументы - это те значения, которые мы передаем в вызове функции

console.log("-----------------7.1---------------------");

// Передача значения по ссылке
const personOne = {
  name: "Bob",
  age: 21,
};

console.log(personOne);
console.log(personOne.age); // 21

function increasePersonAge(person) {
  person.age += 1;
  return person;
} // Ф-ция мутирует внешний объект. Так как personOne и person ссылаются на один и тот же объект в памяти, то соответсвенно personOne так же изменится

increasePersonAge(personOne); // Передача объекта по ссылке (выходит, что мы передаем только ссылку на объект personOne)
// В результате personOne и person будут ссылаться на один объект в памяти
console.log(personOne);
console.log(personOne.age); // 22 - изменился

// ! ВНУТРИ ФУНКЦИИ НЕ РЕКОМЕНДУЕТСЯ МУТИРОВАТЬ ВНЕШНИЕ ОБЪЕКТЫ ---> ПОЭТОМУ СЛЕДУЕТ СОЗДАВАТЬ КОПИИ ОБЪЕКТА

function increasePersonAge2(person) {
  // const updatedPerson = Object.assign({}, person);
  const updatedPerson = { ...person };
  updatedPerson.age += 1; // не мутируем оригинальный объект
  return updatedPerson;
}

const updatedPersonOne = increasePersonAge2(personOne);
console.log(personOne.age); // 22 - не изменился
console.log(updatedPersonOne.age); // 23

console.log("-----------------7.2---------------------");

// Колбэк функции
// callback ф-ция - когда одна ф-ция вызывается внутри другой ф-ции

// Пример 1

function anotherFunction() {
  // Действия...
} // просто объявили ф-цию, которая выполняет какие-то действия
// в данном примере anotherFunction - это callback ф-ция

function fnWithCallback(callbackFunction) {
  callbackFunction(); // в теле fnWithCallback мы вызываем ф-цию callbackFunction (колбэк ф-цию)
} // значением параметра callbackFunction будет другая ф-ция (колбэк ф-ция)

fnWithCallback(anotherFunction); // аргументом в вызове fnWithCallback является другая ф-ция anotherFunction

// Пример 2

function printMyName() {
  console.log("Kate");
}

// setTimeout(printMyName, 1000);
// setTimeout - встроенная ф-ция в JS, доступна по умолчанию как один из методов глобального объекта
// внутри себя вызывает ф-цию, которая передана как 1й аргумент
// ф-ция printMyName (callback ф-ция) будет вызвана через 1000 миллисекунд (определенное время - 2й аргумент)

// Правила работы с функциями:
// 1. Называть ф-ции исходя из выполняемых задач
// 2. Одна ф-ция должна выполнять одну задачу
// 3. Не рекомендуется изменять внешние относительно ф-ции переменные

console.log("-----------------8---------------------");

// ОБЛАСТИ ВИДИМОСТИ
// Область видимости определяет границы действия переменной

// Глобальные переменные - объявлены в глобальной области видимости (window, global, console ...)
// Локальные переменные - объявлены в локальных областях видимости

const x = 5;

function myFunction() {
  function innerFn() {
    console.log(x);
  }
  innerFn();
}

myFunction();

// Цепочка областей видимости: х? {innerFn scope} -> {myFn scope} -> {Global scope} ---> нашли х в глобальной области видимости

// Вызов innerFn() в глобальной области видимости вызовет ошибку, так как эта ф-ция объявлена в локальной области видимости ф-ции myFunction()

console.log("-----------------9---------------------");

// ЖИЗНЕННЫЙ ЦИКЛ ПЕРЕМЕННЫХ
let j; // 1.а. Обяъвление "j" в глобальной области видимости ( = undefined)
let g; // 1.б. Обяъвление "g" в глобальной области видимости ( = undefined)

function myF() {
  let g; // 3.б. Объявление "g" в зоне видимости ф-ции
  j = true; // 3.а. Объявлена ли "j" в зоне видимости ф-ции? НЕТ. Объявлена ли "j" во внешней области видимости? ДА. Присваивание значение true глобальной переменной "j"
  g = 10; // 4.б. Объявлена ли "g" в зоне видимости ф-ции? ДА. Присвоение этой переменной "g" значения 10
  console.log(j); // true
  console.log(g); // 10 - 5.б. "g" имеет значение 10 в области видимости ф-ции
}

myF(); // 2.а. и 2.б. Вызов myF

console.log(j); // true - 4.а. "j" имеет значение true
console.log(g); // undefined - 6.б. "g" всё так же имеет значение undefined в глобальной области

console.log("-----------------10---------------------");

// ТИПЫ ОБЛАСТЕЙ ВИДИМОСТИ
// 1. Глобальная область видимости
// 2. Область видимости ф-ции - создаются каждый раз, когда мы вызываем ту или иную ф-цию, то есть для каждой ф-ции, для каждого вызова ф-ции такая область будет своя
// 3. Область видимости блока - переменные, объявленные с помощью let или const внутри блока имеют область видимости, ограниченную этим блоком
// *: Блок в JS - это любой код, который находится между фигурными скобками
// *: Необъявленные переменные (без let или const) будут автоматически объявлены в глобальной области видимости, то есть доступ к таким переменным будет без ошибки в любой области видимости и это плохо

// Правила работы с переменными
// 1. Все переменные объявлять перед их использованием
// 2. Стараться использовать const везде, где это возможно
// 3. Внутри функций не изменять переменные с внешних областей видимости

// Строгий режим - это инструкция для JS анализировать наш код более пристально. Запрещает использование необъявленных переменных.
// 1 вариант: строка 'use strict' - должна быть первой в глобальной области видимости или в области видимости ф-ции
// 2 вариант - указать в скрипте type='module'
